---
title: DI(Dependency Injection)
author: Junyoung Kim
date: 2021-09-01
category: Android
layout: post
---


### 의존성이란?

클래스들은 종종 다른 클래스들에 대한 참조가 필요하다. 이때 이런 다른 클래스에 대한 참조를 의존성이라고 한다. 의존성을 얻는 방법은 세 가지가 있다.

1. 클래스 내부에서 다른 클래스를 직접 construct하는 방법
2. 다른 곳에서 가져오는 방법 (e.g Context와 `getSystemService()`)
3. **매개변수로 제공 받는 방법**




먼저 첫번째 방법으로 의존성을 제공해보자!

```kotlin
class Car {
    private val engine = Engine()
    fun start() {
        engine.start()
    }
}
fun main(args: Array) {
    val car = Car()
    car.start()
}
```

`Car` 에서 `start` 함수가 호출되기 위해선 `engine` 가 필요하다. 

이를 Car depend on Engine, Car은 Engine 의 의존성을 가진다고 한다. 이때 `Car` 과 `Engine` 은 밀접하게 연결되어 있다. 별로 좋지 않다..


### 의존성 주입이 필요한 이유

현재 `Car` 은 `Engine` 만을 사용하고 있다. 만약 엔진 회사에서 `SuperEngine` 이라는 새로운 엔진을 개발해 `Car` 클래스에 `Engine` 클래스 대신 `SuperEngine` 클래스를 사용하고 싶다면 코드를 다음과 같이 수정해줘야 한다.

```kotlin
class SuperEngine : Engine() { ... }

class Car {
    private val engine = SuperEngine() // 수정된 부분
    fun start() {
        engine.start()
    }
}
fun main(args: Array) {
    val car = Car()
    car.start()
}
```

`SuperEngine` 외에 `HyperEngine`, `UltraEngine` 을 사용하려면 위와 같이 코드를 매번 수정해줘야 한다.  비효율적이다! 또한 `Engine` 의 종류를 바꿔줘야할 때마다 코드를 수정해줘야 하기 때문에 리팩토링이 어렵고 코드를 재사용하기 어렵다. 이는 클래스 간의 결합도가 높아서 생기는 문제이다. 클래스 간의 결합도가 높으면 한 클래스가 변할때 다른 클래스도 영향을 받는다.


이러한 문제점을 해결하기 위해 세번째 방법, 의존성 주입이 등장했다!

### 의존성 주입(Dependency Injection)이란?

의존성 주입이란 클래스간 의존성을 클래스 외부에서 주입하는 것을 의미한다. 단순하게 클래스 A에서 클래스 B를 필요로 할때, 클래스 B를 외부에서 넣어준다고 생각할 수 있다.

위의 코드를 의존성 주입을 사용해 수정해보자!

```kotlin
class SuperEngine : Engine() { ... }
class HyperEngine : Engine() { ... }

class Car(private val engine: Engine) {
    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val engine = Engine()
    val car = Car(engine)
    
    	val superEngine = SuperEngine()
		val superCar = Car(superEngine)
}
```

 의존성 주입을 사용하게 되면 `Car` 내부에서  `Engine` 을 생성하지 않고 `Car` 의 생성자에 `Engine` 객체를 받게 된다. 이전에는 다른 엔진을 사용하려면 코드를 수정해야했는데, 이제는 그럴 필요 없이 생성자에 다른 엔진을 넘겨주기만 하면 된다. 

**💡  `Car` 클래스의 재사용성이 높아진다!**


또한 엔진을 갈아끼우기 쉬워져 `Car` 의 수정이 용이해졌으며 `Car` 을 테스트해보기 위한 `FakeEngine` 같은 것도 넣어볼 수 있게 되었다.

💡 **`Car` 클래스의 리팩토링이 쉬워졌다!**

**💡 `Car` 클래스의 테스트가 쉬워졌다!**



### 의존성 주입 조건

1. 클래스 모델이나 코드에 런타임 시점의 의존 관계가 들어나지 않는다.
2. 런타임 시점의 의존관계는 제 3의 존재에 의해 결정되어야 한다.
3. 의존 관계는 사용할 object에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

객체지향 5대원칙 혹은 SOLID 원칙 중 **DIP(의존 역전 원칙)**이 있다. 상위 모듈은 하위 모듈에 의존해서는 안된다. 하위 레벨의 변경이 상위 레벨의 모듈의 변경을 요구하는 관계를 추상을 매개로 최대한 느슨하게 만드는 원칙이다! **DI는 DIP를 구현하는 방법 중 하나이다.**

### 의존성 주입 방법

1. **Constructor Injection**

    위의 예제처럼 생성자를 사용해서 의존성을 주입해준다.

2. **Field Injection (Setter Injection)**

    엑티비티나 프래그먼트는 시스템에 의해 인스턴스화된다. 따라서 클래스가 생성되고 의존성이 주입되어야 한다.

    ```kotlin
    class Car {
        lateinit var engine: Engine
        fun start() {
            engine.start()
        }
    }

    fun main(args: Array) {
        val car = Car()
        car.engine = Engine()
        car.start()
    }
    ```

### DI 라이브러리

수동으로 의존성을 주입해주는 방법 외에 자동으로 의존성을 주입해주는 라이브러리가 있다. 의존성 주입 라이브러리는 런타임 시 의존성을 연결해주는 Reflection-based 라이브러리와 컴파일 시 의존성을 연결해주는 정적 라이브러리가 있다.

1. Dagger
    - Java와 Kotlin 모두 지원해주는 라이브러리이다.
    - 컴파일단에서 동작한다,
2. Koin
    - Kotlin만 지원해주는 라이브러리이다.
    - 런타임에서 의존성을 주입해주는 라이브러리이다.
3. Hilt
    - 기존 Dager을 기반으로 한 라이브러리로 Dagger보다 러닝 커브가 낮고 안드로이드 앱에 최적화되어 있다.

### TL;DR

```
의존성 주입은 클래스 재사용과 리팩터링, 테스트의 편의성을 높여준다.
```